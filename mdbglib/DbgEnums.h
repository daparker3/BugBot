#pragma once

namespace MS
{
	namespace Debuggers
	{
		namespace DbgEng
		{
			typedef IDebugAdvanced2 DbgAdvanced;
			typedef IDebugClient5 DbgClient;
			typedef IDebugControl4 DbgControl;
			typedef IDebugDataSpaces4 DbgDataSpaces;
			typedef IDebugRegisters2 DbgRegisters;
			typedef IDebugSymbols3 DbgSymbols; 
			typedef IDebugSystemObjects4 DbgSystemObjects;
			typedef IDebugBreakpoint2 DbgBreakpoint;

			public enum class DebugEvent
			{
/*
DEBUG_EVENT_BREAKPOINT Breakpoint A breakpoint exception occurred in the target. 
DEBUG_EVENT_EXCEPTION Exception An exception debugging event occurred in the target. 
DEBUG_EVENT_CREATE_THREAD CreateThread A create-thread debugging event occurred in the target. 
DEBUG_EVENT_EXIT_THREAD ExitThread An exit-thread debugging event occurred in the target. 
DEBUG_EVENT_CREATE_PROCESS CreateProcess A create-process debugging event occurred in the target. 
DEBUG_EVENT_EXIT_PROCESS ExitProcess An exit-process debugging event occurred in the target. 
DEBUG_EVENT_LOAD_MODULE LoadModule A module-load debugging event occurred in the target. 
DEBUG_EVENT_UNLOAD_MODULE UnloadModule A module-unload debugging event occurred in the target. 
DEBUG_EVENT_SYSTEM_ERROR SystemError A system error occurred in the target. 


The following events are generated by the debugger engine.
DEBUG_EVENT_SESSION_STATUS SessionStatus A change has occurred in the session status. 
DEBUG_EVENT_CHANGE_DEBUGGEE_STATE ChangeDebuggeeState The engine has made or detected a change in the target status. 
DEBUG_EVENT_CHANGE_ENGINE_STATE ChangeEngineState The engine state has changed. 
DEBUG_EVENT_CHANGE_SYMBOL_STATE ChangeSymbolState The symbol state has changed. 

*/
				Breakpoint = DEBUG_EVENT_BREAKPOINT,
				Exception = DEBUG_EVENT_EXCEPTION,
				CreateThread = DEBUG_EVENT_CREATE_THREAD,
				ExitThread = DEBUG_EVENT_EXIT_THREAD,
				CreateProcess = DEBUG_EVENT_CREATE_PROCESS,
				ExitProcess = DEBUG_EVENT_EXIT_PROCESS,
				LoadModule = DEBUG_EVENT_LOAD_MODULE,
				UnloadModule = DEBUG_EVENT_UNLOAD_MODULE,
				SystemError = DEBUG_EVENT_SYSTEM_ERROR,

				SessionStatus = DEBUG_EVENT_SESSION_STATUS,
				ChangeDebuggeeState = DEBUG_EVENT_CHANGE_DEBUGGEE_STATE,
				ChangeEngineState = DEBUG_EVENT_CHANGE_ENGINE_STATE,
				ChangeSymbolState = DEBUG_EVENT_CHANGE_SYMBOL_STATE
			};

			public enum class CreateFlags
			{
				DebugProcess			= DEBUG_PROCESS, //                       0x00000001
				DebugOnlyThisProcess	= DEBUG_ONLY_THIS_PROCESS, //             0x00000002
				CreateSuspended			= CREATE_SUSPENDED, //                    0x00000004
				CreateNewConsole		= CREATE_NEW_CONSOLE, //                  0x00000010
				StackSizeParamIsAReservation = STACK_SIZE_PARAM_IS_A_RESERVATION, //0x00010000
				InheritCallerPriority	= INHERIT_CALLER_PRIORITY, //             0x00020000

// On Windows XP this flag prevents the debug
// heap from being used in the new process.
				NoDebugHeap				= DEBUG_CREATE_PROCESS_NO_DEBUG_HEAP,	//    CREATE_UNICODE_ENVIRONMENT
// Indicates that the native NT RTL process creation
// routines should be used instead of Win32.  This
// is only meaningful for special processes that run
// as NT native processes.
				ProcessThroughRTL		= DEBUG_CREATE_PROCESS_THROUGH_RTL		//    STACK_SIZE_PARAM_IS_A_RESERVATION
			};

			public enum class EngCreateFlags
			{
				Default					= DEBUG_ECREATE_PROCESS_DEFAULT,			//    0x00000000
				InheritHandles			= DEBUG_ECREATE_PROCESS_INHERIT_HANDLES,	//    0x00000001
				UseVerifierFlags		= DEBUG_ECREATE_PROCESS_USE_VERIFIER_FLAGS, //    0x00000002
				UseImplicitCommandLine	= DEBUG_ECREATE_PROCESS_USE_IMPLICIT_COMMAND_LINE // 0x00000004
			};

			public value class DebugCreateProcessOptions
			{
			public:
				CreateFlags CreateFlags;
				EngCreateFlags EngCreateFlags;
				ULONG  VerifierFlags;
				ULONG  Reserved;

			internal:
				DEBUG_CREATE_PROCESS_OPTIONS ToLegacy()
				{
					DEBUG_CREATE_PROCESS_OPTIONS result;
					result.CreateFlags = (ULONG)this->CreateFlags;
					result.EngCreateFlags = (ULONG)this->EngCreateFlags;
					result.VerifierFlags = this->VerifierFlags;
					result.Reserved = this->Reserved;
					return result;
				}
			};

			private enum class ModuleNameType
			{
				Image			= DEBUG_MODNAME_IMAGE,
				Module			= DEBUG_MODNAME_MODULE,
				LoadedImage		= DEBUG_MODNAME_LOADED_IMAGE,
				SymbolFile		= DEBUG_MODNAME_SYMBOL_FILE,
				MappedImage		= DEBUG_MODNAME_MAPPED_IMAGE
			};

			public enum class OutputFlags
			{
				// Output mask bits.
// Normal output.
				Normal			= DEBUG_OUTPUT_NORMAL, //            0x00000001
// Error output.
				Error			= DEBUG_OUTPUT_ERROR, //             0x00000002
// Warnings.
				Warning			= DEBUG_OUTPUT_WARNING, //           0x00000004
// Additional output.
				Verbose			= DEBUG_OUTPUT_VERBOSE, //           0x00000008
// Prompt output.
				Prompt			= DEBUG_OUTPUT_PROMPT, //            0x00000010
// Register dump before prompt.
				PromptRegisters = DEBUG_OUTPUT_PROMPT_REGISTERS, //  0x00000020
// Warnings specific to extension operation.
				ExtensionWarning = DEBUG_OUTPUT_EXTENSION_WARNING, //0x00000040
// Debuggee debug output, such as from OutputDebugString.
				Debuggee		= DEBUG_OUTPUT_DEBUGGEE, //          0x00000080
// Debuggee-generated prompt, such as from DbgPrompt.
				DebuggeePrompt	= DEBUG_OUTPUT_DEBUGGEE_PROMPT, //   0x00000100
// Symbol messages, such as for !sym noisy.
				Symbols			= DEBUG_OUTPUT_SYMBOLS  //           0x00000200

				////BreakpointOutput = 0x20000000,
				//Debuggee_		= DEBUG_OUTPUT_DEBUGGEE,
				//DebuggeePrompt	= DEBUG_OUTPUT_DEBUGGEE_PROMPT,
				//Error			= DEBUG_OUTPUT_ERROR,
				////EventOutput = 0x10000000,
				//ExtensionWarning = DEBUG_OUTPUT_EXTENSION_WARNING,
				////KdProtocolOutput = -2147483648,
				//Normal			= 1,
				//Prompt			= DEBUG_OUTPUT_PROMPT,
				//PromptRegisters = DEBUG_OUTPUT_PROMPT_REGISTERS,
				////RemotingOutput = 0x40000000,
				//Symbols			= DEBUG_OUTPUT_SYMBOLS,
				//Verbose			= DEBUG_OUTPUT_VERBOSE,
				//Warning			= DEBUG_OUTPUT_WARNING
			};

			public enum class DbgExpressionType
			{
				MASM			= DEBUG_EXPR_MASM,
				CPP				= DEBUG_EXPR_CPLUSPLUS
			};

			public enum class DbgValueType
			{
				Invalid			= DEBUG_VALUE_INVALID,
				Integer8		= DEBUG_VALUE_INT8,
				Integer16		= DEBUG_VALUE_INT16,
				Integer32		= DEBUG_VALUE_INT32,
				Integer64		= DEBUG_VALUE_INT64,
				Float32			= DEBUG_VALUE_FLOAT32,
				Float64			= DEBUG_VALUE_FLOAT64,
				Float80			= DEBUG_VALUE_FLOAT80,
				Float82			= DEBUG_VALUE_FLOAT82,
				Float128		= DEBUG_VALUE_FLOAT128,
				Vector64		= DEBUG_VALUE_VECTOR64,
				Vector128		= DEBUG_VALUE_VECTOR128
			};

			public enum class SymbolMode
			{
				NoType			= 0,
				Coff			= 1,
				CodeView		= 2,
				Pdb				= 3,
				Export			= 4,
				Deferred		= 5,
				Sym				= 6,
				Dia				= 7
			};

			public enum class ModuleFlags
			{
				Unloaded		= DEBUG_MODULE_UNLOADED,
				UserMode		= DEBUG_MODULE_USER_MODE,
				BadChecksum		= DEBUG_MODULE_SYM_BAD_CHECKSUM
			};

			public enum class DumpType
			{
/*
DEBUG_DUMP_SMALL Small Memory Dump (kernel-mode) or Minidump (user-mode). 
DEBUG_DUMP_DEFAULT Full User-Mode Dump (user-mode) or Kernel Summary Dump (kernel-mode). 
DEBUG_DUMP_FULL (kernel-mode only) Complete Memory Dump. 

Moreover, the following aliases are available for kernel-mode debugging.

DEBUG_KERNEL_SMALL_DUMP DEBUG_DUMP_SMALL 
DEBUG_KERNEL_DUMP DEBUG_DUMP_DEFAULT 
DEBUG_KERNEL_FULL_DUMP DEBUG_DUMP_FULL 

Additionally, the following aliases are available for user-mode debugging.

DEBUG_USER_WINDOWS_SMALL_DUMP DEBUG_DUMP_SMALL 
DEBUG_USER_WINDOWS_DUMP DEBUG_DUMP_DEFAULT 
*/
				Default		= DEBUG_DUMP_DEFAULT,
				Small		= DEBUG_DUMP_SMALL,
				Full		= DEBUG_DUMP_FULL
			};

			public enum class DumpFlags
			{
/*
DEBUG_FORMAT_USER_SMALL_FULL_MEMORY Add full memory data. All accessible committed pages owned by the target application will be included. 
DEBUG_FORMAT_USER_SMALL_HANDLE_DATA Add data about the handles that are associated with the target application. 
DEBUG_FORMAT_USER_SMALL_UNLOADED_MODULES Add unloaded module information. This information is available only in Windows Server 2003 and later versions of Windows. 
DEBUG_FORMAT_USER_SMALL_INDIRECT_MEMORY Add indirect memory. A small region of memory that surrounds any address that is referenced by a pointer on the stack or backing store is included. 
DEBUG_FORMAT_USER_SMALL_DATA_SEGMENTS Add all data segments within the executable images. 
DEBUG_FORMAT_USER_SMALL_FILTER_MEMORY Set to zero all of the memory on the stack and in the backing store that is not useful for recreating the stack trace. This can make compression of the Minidump more efficient and increase privacy by removing unnecessary information. 
DEBUG_FORMAT_USER_SMALL_FILTER_PATHS Remove the module paths, leaving only the module names. This is useful for protecting privacy by hiding the directory structure (which may contain the user’s name). 
DEBUG_FORMAT_USER_SMALL_PROCESS_THREAD_DATA Add the process environment block (PEB) and thread environment block (TEB). This flag can be used to provide Windows system information for threads and processes. 
DEBUG_FORMAT_USER_SMALL_PRIVATE_READ_WRITE_MEMORY Add all committed private read-write memory pages. 
DEBUG_FORMAT_USER_SMALL_NO_OPTIONAL_DATA Prevent privacy-sensitive data from being included in the Minidump. Currently, this flag excludes from the Minidump data that would have been added due to the following flags being set: DEBUG_FORMAT_USER_SMALL_PROCESS_THREAD_DATA, DEBUG_FORMAT_USER_SMALL_FULL_MEMORY, DEBUG_FORMAT_USER_SMALL_INDIRECT_MEMORY, DEBUG_FORMAT_USER_SMALL_PRIVATE_READ_WRITE_MEMORY. 
DEBUG_FORMAT_USER_SMALL_FULL_MEMORY_INFO Add all basic memory information. This is the information returned by the QueryVirtual method. The information for all memory is included, not just valid memory, which allows the debugger to reconstruct the complete virtual memory layout from the Minidump. 
DEBUG_FORMAT_USER_SMALL_THREAD_INFO Add additional thread information, which includes execution time, start time, exit time, start address, and exit status. 
DEBUG_FORMAT_USER_SMALL_CODE_SEGMENTS Add all code segments with the executable images. 
*/
				FullMemory			= DEBUG_FORMAT_USER_SMALL_FULL_MEMORY,
				HandleData			= DEBUG_FORMAT_USER_SMALL_HANDLE_DATA,
				UnloadedModules		= DEBUG_FORMAT_USER_SMALL_UNLOADED_MODULES,
				IndirectMemory		= DEBUG_FORMAT_USER_SMALL_INDIRECT_MEMORY,
				DataSegments		= DEBUG_FORMAT_USER_SMALL_DATA_SEGMENTS,
				FilterMemory		= DEBUG_FORMAT_USER_SMALL_FILTER_MEMORY,
				FilterPaths			= DEBUG_FORMAT_USER_SMALL_FILTER_PATHS,
				ThreadData			= DEBUG_FORMAT_USER_SMALL_PROCESS_THREAD_DATA,
				PrivateRWMemory		= DEBUG_FORMAT_USER_SMALL_PRIVATE_READ_WRITE_MEMORY,
				NoOptionalData		= DEBUG_FORMAT_USER_SMALL_NO_OPTIONAL_DATA,
				FullMemoryInfo		= DEBUG_FORMAT_USER_SMALL_FULL_MEMORY_INFO,
				ThreadInfo			= DEBUG_FORMAT_USER_SMALL_THREAD_INFO,
				CodeSegments		= DEBUG_FORMAT_USER_SMALL_CODE_SEGMENTS
			};

			public enum class AttachFlags
			{
/*
DEBUG_ATTACH_NONINVASIVE Attach to the target noninvasively. For more information about noninvasive debugging, see Noninvasive Debugging (User Mode).
If this flag is set, then the flags DEBUG_ATTACH_EXISTING, DEBUG_ATTACH_INVASIVE_NO_INITIAL_BREAK, and DEBUG_ATTACH_INVASIVE_RESUME_PROCESS must not be set.

DEBUG_ATTACH_EXISTING Re-attach to an application to which a debugger has already attached (and possibly abandoned). For more information about re-attaching to targets, see Re-attaching to the Target Application.
If this flag is set, then the other DEBUG_ATTACH_XXX flags must not be set.

DEBUG_ATTACH_NONINVASIVE_NO_SUSPEND Do not suspend the target's threads when attaching noninvasively.
If this flag is set, then the flag DEBUG_ATTACH_NONINVASIVE must also be set.

DEBUG_ATTACH_INVASIVE_NO_INITIAL_BREAK (Windows XP and later) Do not request an initial break-in when attaching to the target.
If this flag is set, then the flags DEBUG_ATTACH_NONINVASIVE and DEBUG_ATTACH_EXISTING must not be set.

DEBUG_ATTACH_INVASIVE_RESUME_PROCESS Resume all of the target's threads when attaching invasively.
If this flag is set, then the flags DEBUG_ATTACH_NONINVASIVE and DEBUG_ATTACH_EXISTING must not be set.
*/
				NonInvasive				= DEBUG_ATTACH_NONINVASIVE,
				Existing				= DEBUG_ATTACH_EXISTING,
				NonInvasiveNoSuspend	= DEBUG_ATTACH_NONINVASIVE_NO_SUSPEND,
				InvasiveNoInitialBreak	= DEBUG_ATTACH_INVASIVE_NO_INITIAL_BREAK,
				InvasiveResumeProcess	= DEBUG_ATTACH_INVASIVE_RESUME_PROCESS
			};

			public enum class DebugStatus
			{
				NoChange				= DEBUG_STATUS_NO_CHANGE,	//           0
				Go						= DEBUG_STATUS_GO,			//           1
				GoHandled				= DEBUG_STATUS_GO_HANDLED,	//           2
				GoNotHandled			= DEBUG_STATUS_GO_NOT_HANDLED, //        3
				StepOver				= DEBUG_STATUS_STEP_OVER,	//           4
				StepInto				= DEBUG_STATUS_STEP_INTO,	//           5
				Break					= DEBUG_STATUS_BREAK,		//           6
				NoDebuggee				= DEBUG_STATUS_NO_DEBUGGEE,	//           7
				StopBranch				= DEBUG_STATUS_STEP_BRANCH,	//           8
				IgnoreEvent				= DEBUG_STATUS_IGNORE_EVENT, //          9
				RestartRequested		= DEBUG_STATUS_RESTART_REQUESTED, //     10
				ReverseGo				= DEBUG_STATUS_REVERSE_GO,	//           11
				ReverseStepBranch		= DEBUG_STATUS_REVERSE_STEP_BRANCH, //   12
				ReverseStepOver			= DEBUG_STATUS_REVERSE_STEP_OVER, //     13
				ReverseStepInto			= DEBUG_STATUS_REVERSE_STEP_INTO, //     14
			};

			public enum class DebugOutputControl
			{
// Output control flags.
// Output generated by methods called by this
// client will be sent only to this clients
// output callbacks.
				ThisClient				= DEBUG_OUTCTL_THIS_CLIENT,	//       0x00000000
// Output will be sent to all clients.
				AllClients				= DEBUG_OUTCTL_ALL_CLIENTS,	//       0x00000001
// Output will be sent to all clients except
// the client generating the output.
				AllOtherClients			= DEBUG_OUTCTL_ALL_OTHER_CLIENTS, //  0x00000002
// Output will be discarded immediately and will not
// be logged or sent to callbacks.
				Ignore					= DEBUG_OUTCTL_IGNORE,		//       0x00000003
// Output will be logged but not sent to callbacks.
				LogOnly					= DEBUG_OUTCTL_LOG_ONLY,	//       0x00000004
// All send control bits.
				SendMask				= DEBUG_OUTCTL_SEND_MASK,	//       0x00000007
// Do not place output from this client in
// the global log file.
				NotLogged				= DEBUG_OUTCTL_NOT_LOGGED,	//       0x00000008
// Send output to clients regardless of whether the
// mask allows it or not.
				OverrideMask			= DEBUG_OUTCTL_OVERRIDE_MASK, //     0x00000010
// Text is markup instead of plain text.
//				DML						= DEBUG_OUTCTL_DML,			//       0x00000020

// Special values which mean leave the output settings
// unchanged.
//				AmbientDML				= DEBUG_OUTCTL_AMBIENT_DML,	//       0xfffffffe
//				AmbientTest				= DEBUG_OUTCTL_AMBIENT_TEXT, //      0xffffffff

// Old ambient flag which maps to text.
				Ambient					= DEBUG_OUTCTL_AMBIENT		//       DEBUG_OUTCTL_AMBIENT_TEXT
			};

			public enum class DebugExecuteFlags
			{
// Execute and ExecuteCommandFile flags.
// These flags only apply to the command
// text itself; output from the executed
// command is controlled by the output
// control parameter.
// Default execution.  Command is logged
// but not output.
				Default					= DEBUG_EXECUTE_DEFAULT,	//       0x00000000
// Echo commands during execution.  In
// ExecuteCommandFile also echoes the prompt
// for each line of the file.
				Echo					= DEBUG_EXECUTE_ECHO,		//       0x00000001
// Do not log or output commands during execution.
// Overridden by DEBUG_EXECUTE_ECHO.
				NotLogged				= DEBUG_EXECUTE_NOT_LOGGED,	//       0x00000002
// If this flag is not set an empty string
// to Execute will repeat the last Execute
// string.
				NoRepeat				= DEBUG_EXECUTE_NO_REPEAT,	//       0x00000004
			};

			public enum class TypeOptions
			{
//
// Type options, used with Get/SetTypeOptions.
//
// Display PUSHORT and USHORT arrays in Unicode.
				UnicodeDisplay			= DEBUG_TYPEOPTS_UNICODE_DISPLAY, //    0x00000001
// Display LONG types in default base instead of decimal.
				LongStatusDisplay		= DEBUG_TYPEOPTS_LONGSTATUS_DISPLAY, // 0x00000002
// Display integer types in default base instead of decimal.
				ForceRadisOutput		= DEBUG_TYPEOPTS_FORCERADIX_OUTPUT, //  0x00000004
// Search for the type/symbol with largest size when
// multiple type/symbol match for a given name
				MatchMaxsize			= DEBUG_TYPEOPTS_MATCH_MAXSIZE  //      0x00000008
			};

			public enum class GetMethodFlags
			{
				// Scan all modules, loaded and unloaded.
				Default					= DEBUG_GETMOD_DEFAULT,        //     0x00000000
// Do not scan loaded modules.
				NoLoadedModules			= DEBUG_GETMOD_NO_LOADED_MODULES, //   0x00000001
// Do not scan unloaded modules.
				NoUloadedModules		= DEBUG_GETMOD_NO_UNLOADED_MODULES, // 0x00000002
			};

			public enum class GetRunningProcessSystemIdByExecutableNameFlags
			{
// Get the process ID by matching the full path of the name.
				FullMatch               = DEBUG_GET_PROC_FULL_MATCH,
// Get the process ID by matching only the image name.
				ProcOnlyMatch           = DEBUG_GET_PROC_ONLY_MATCH
			};
			
			[System::FlagsAttribute]
			public enum class GetRunningProcessDescriptionFlags
			{
// Return only file names without path names.
				NoPaths                 = DEBUG_PROC_DESC_NO_PATHS,
// Do not look up service names.
				NoServices              = DEBUG_PROC_DESC_NO_SERVICES,
// Do not look up MTS package names.
				NoMtsPackages           = DEBUG_PROC_DESC_NO_MTS_PACKAGES,
// Do not look up the process command line.
				NoCommandLine           = DEBUG_PROC_DESC_NO_COMMAND_LINE
			};

			[System::FlagsAttribute]
			public enum class EngineOptionsEnum
			{
				IgnoreDbghelpVersion = DEBUG_ENGOPT_IGNORE_DBGHELP_VERSION,
// The debugger engine generates a warning instead of an error if the version of the DbgHelp DLL does not match the version of the debugger engine. 
				IgnoreExtensionVersions = DEBUG_ENGOPT_IGNORE_EXTENSION_VERSIONS,
// Disable version checking for extensions. This suppresses the debugger engine's call to CheckVersion. 
				AllowNetworkPaths = DEBUG_ENGOPT_ALLOW_NETWORK_PATHS,
// Network shares can be used for loading symbols and extensions. This option prevents the engine from disallowing network paths when debugging some system processes and should be used with caution.
// This option cannot be set if DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS is set.
				DisallowNetworkPaths = DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS,
// Network shares cannot be used for loading symbols and extensions. The engine attempts to set this option when debugging some system processes.
// This option cannot be set if DEBUG_ENGOPT_ALLOW_NETWORK_PATHS is set.
				IgnoreLoaderExceptions = DEBUG_ENGOPT_IGNORE_LOADER_EXCEPTIONS,
// Ignore expected first-chance exceptions that are generated by the loader in certain versions of Windows.
// For example, this option allows Windows 3.51 binaries to run when debugging Windows 3.1 and 3.5 systems.
				InitialBreak = DEBUG_ENGOPT_INITIAL_BREAK,
// Break into the debugger at the target's initial event. 
				InitialModuleBreak = DEBUG_ENGOPT_INITIAL_MODULE_BREAK,
// Break into the debugger when the target loads its first module. 
				FinalBreak = DEBUG_ENGOPT_FINAL_BREAK,
// Break into the debugger at the target's final event. In a live user-mode target, this is when the process exits. It has no effect in kernel mode. 
				NoExecuteRepeat = DEBUG_ENGOPT_NO_EXECUTE_REPEAT,
// When given an empty command, the debugger engine does not repeat the last command. 
				FailIncompleteInformation = DEBUG_ENGOPT_FAIL_INCOMPLETE_INFORMATION,
// Prevent the debugger from loading modules whose images cannot be mapped.
// The debugger attempts to load images when debugging minidumps that do not contain images.
				AllowReadOnlyBreakpoints = DEBUG_ENGOPT_ALLOW_READ_ONLY_BREAKPOINTS,
// Allow the debugger engine to manipulate page protections on the target to allow for setting software breakpoints in a read-only section of memory.
// When setting software breakpoints, the engine transparently alters the target's memory to insert an interrupt instruction.
				SynchronizeBreakpoints = DEBUG_ENGOPT_SYNCHRONIZE_BREAKPOINTS,
// In live user-mode debugging, the engine performs extra work when inserting and removing breakpoints to ensure that all threads in the target have a consistent breakpoint state at all times.
// This option is useful when multiple threads can use the code for which the breakpoint is set. However, it can introduce the possibility of deadlocks.
				DisallowShellCommands = DEBUG_ENGOPT_DISALLOW_SHELL_COMMANDS,
// Disallow executing shell commands through the debugger.
// After this option has been set, it cannot be unset.
				QuietMode = DEBUG_ENGOPT_KD_QUIET_MODE,
// Turn on quiet mode. For more information, see sq (Set Quiet Mode).  
				DisableManagedSupport = DEBUG_ENGOPT_DISABLE_MANAGED_SUPPORT,
// Disables debugger engine support for managed code. If support for managed code is already in use, this option has no effect. 
				DisableModuleSymbolLoad = DEBUG_ENGOPT_DISABLE_MODULE_SYMBOL_LOAD,
// The debugger does not load symbols for modules that are loaded while this flag is set. 
				DisableExecutionCommands = DEBUG_ENGOPT_DISABLE_EXECUTION_COMMANDS
// Prevents any commands that would cause the target to begin executing. 
			};
			
			public enum class SessionStatusFlags
			{
				// A debugger session has started.
				SessionActive = DEBUG_SESSION_ACTIVE,
				// The session was ended by sending DEBUG_END_ACTIVE_TERMINATE to EndSession.
				SessionActiveTerminate = DEBUG_SESSION_END_SESSION_ACTIVE_TERMINATE,
				// The session was ended by sending DEBUG_END_ACTIVE_DETACH to EndSession.
				SessionActiveDetach = DEBUG_SESSION_END_SESSION_ACTIVE_DETACH,
				// The session was ended by sending DEBUG_END_PASSIVE to EndSession.
				SessionEndSessionPassive = DEBUG_SESSION_END_SESSION_PASSIVE,
				// The target ran to completion, ending the session.
				SessionEnd = DEBUG_SESSION_END,
				// The target computer rebooted, ending the session.
				SessionReboot = DEBUG_SESSION_REBOOT,
				// The target computer went into hibernation, ending the session.
				SessionHibernate = DEBUG_SESSION_HIBERNATE,
				// The engine was unable to continue the session.
				SessionFailure = DEBUG_SESSION_FAILURE,
			};

			[System::FlagsAttribute]
			public enum class BreakpointFlags
			{
				Enabled = DEBUG_BREAKPOINT_ENABLED,
				AdderOnly = DEBUG_BREAKPOINT_ADDER_ONLY,
				GoOnly = DEBUG_BREAKPOINT_GO_ONLY,
				OneShot = DEBUG_BREAKPOINT_ONE_SHOT,
				Deferred = DEBUG_BREAKPOINT_DEFERRED
			};

			public enum class BreakpointTypeFlags
			{
				Code = DEBUG_BREAKPOINT_CODE,
				Data = DEBUG_BREAKPOINT_DATA
			};

			[System::FlagsAttribute]
			public enum class ExceptionFlags
			{
				// The thread tried to read from or write to a virtual address for which it does not have the appropriate access.
				AccessViolation = EXCEPTION_ACCESS_VIOLATION,
				// The thread tried to access an array element that is out of bounds and the underlying hardware supports bounds checking.
				ArrayBoundsExceeded = EXCEPTION_ARRAY_BOUNDS_EXCEEDED,
				// A breakpoint was encountered.
				Breakpoint = EXCEPTION_BREAKPOINT,
				// The thread tried to read or write data that is misaligned on hardware that does not provide alignment. For example, 16-bit values must be aligned on 2-byte boundaries; 32-bit values on 4-byte boundaries, and so on.
				DatatypeMisalignment = EXCEPTION_DATATYPE_MISALIGNMENT,
				// One of the operands in a floating-point operation is denormal. A denormal value is one that is too small to represent as a standard floating-point value.
				DenormalOperation = EXCEPTION_FLT_DENORMAL_OPERAND,
				// The thread tried to divide a floating-point value by a floating-point divisor of zero.
				FloatDivZero = EXCEPTION_FLT_DIVIDE_BY_ZERO,
				// The result of a floating-point operation cannot be represented exactly as a decimal fraction.
				FloatInexactResult = EXCEPTION_FLT_INEXACT_RESULT,
				// This exception represents any floating-point exception not included in this list.
				FloatInvalidOperation = EXCEPTION_FLT_INVALID_OPERATION,
				// The exponent of a floating-point operation is greater than the magnitude allowed by the corresponding type.
				FloatOverflow = EXCEPTION_FLT_OVERFLOW,
				// The stack overflowed or underflowed as the result of a floating-point operation.
				FloatStackCheck = EXCEPTION_FLT_STACK_CHECK,
				// The exponent of a floating-point operation is less than the magnitude allowed by the corresponding type.
				FloatUnderflow = EXCEPTION_FLT_UNDERFLOW,
				// The thread tried to execute an invalid instruction.
				FloatIllegalInstruction = EXCEPTION_ILLEGAL_INSTRUCTION,
				// The thread tried to access a page that was not present, and the system was unable to load the page. For example, this exception might occur if a network connection is lost while running a program over the network.
				InPageError = EXCEPTION_IN_PAGE_ERROR,
				// The thread tried to divide an integer value by an integer divisor of zero.
				IntDivZero = EXCEPTION_INT_DIVIDE_BY_ZERO,
				// The result of an integer operation caused a carry out of the most significant bit of the result.
				IntOverflow = EXCEPTION_INT_OVERFLOW,
				// An exception handler returned an invalid disposition to the exception dispatcher. Programmers using a high-level language such as C should never encounter this exception.
				InvalidDisposition = EXCEPTION_INVALID_DISPOSITION,
				// The thread tried to continue execution after a noncontinuable exception occurred.
				Noncontinuable = EXCEPTION_NONCONTINUABLE_EXCEPTION,
				// The thread tried to execute an instruction whose operation is not allowed in the current machine mode.
				PrivInstruction = EXCEPTION_PRIV_INSTRUCTION,
				// A trace trap or other single-instruction mechanism signaled that one instruction has been executed.
				SingleStep = EXCEPTION_SINGLE_STEP,
				// The thread used up its stack.
				StackOverflow = EXCEPTION_STACK_OVERFLOW,
			};

			// Specifies the type of interrupt to register. Flags can take one of the values listed in the following table.
			public enum class DebugInterruptFlags
			{
				//If the target is running, the engine will request a break into the debugger. This request might time out. 
				Active = DEBUG_INTERRUPT_ACTIVE,
				//The engine will register a user interrupt.
				Passive = DEBUG_INTERRUPT_PASSIVE,
				// If there is currently a WaitForEvent call running, the engine will force it to return. 
				Exit = DEBUG_INTERRUPT_EXIT
			};

		}
	}
}